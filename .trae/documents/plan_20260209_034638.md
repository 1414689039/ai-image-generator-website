I will implement the storage of generated images in your R2 bucket to ensure persistence and reliability, avoiding issues with API provider link expiration.

### Implementation Plan

1.  **Create Image Upload Helper**
    *   Implement a helper function `processAndUploadImages` in `generation.ts`.
    *   This function will:
        *   Accept a list of source URLs and the Generation ID.
        *   Download each image from the API provider.
        *   Upload the image to your R2 bucket (`IMAGES` binding) with a unique key (e.g., `gen_{id}_{index}_{timestamp}.png`).
        *   Return the new public URLs (e.g., `/images/...`).
        *   Includes error handling: if an upload fails, it falls back to the original URL to ensure the user still gets an image.

2.  **Update Asynchronous Polling (`GET /check/:id`)**
    *   In the task status check logic, when a task is reported as `success` or `completed` by the API:
    *   Trigger the `processAndUploadImages` function to transfer images to R2.
    *   Update the database `result_urls` with the **new R2 URLs** instead of the temporary API links.
    *   This ensures that when the frontend receives the "Completed" status, it gets permanent links.

3.  **Update Synchronous Creation (`POST /create`)**
    *   In the background task handling (for APIs that return images immediately):
    *   Add the same `processAndUploadImages` logic before saving the result to the database.

### Why this approach?
*   **Reliability**: You own the data. API provider links often expire after 1-24 hours.
*   **Consistency**: All images (reference and generated) will be served from the same domain (`/images/...`).
*   **User Experience**: Prevents "Image Expired" errors in the history gallery.
